// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Our User model, which will become the "users" table in the database
model User {
  id       String @id @default(uuid())
  email    String @unique
  fullName String
  password String
  level    Int    @default(1)

  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  completedStories CompletedStory[]
}

// A model to store OTPs and reset tokens securely in the database
model PasswordResetToken {
  id      String   @id @default(uuid())
  email   String
  token   String   @unique // This will be our OTP or a longer-lived token
  expires DateTime

  @@index([email]) // Add an index to the email field for faster lookups
}

model StoryTrail {
  id              String @id @default(uuid())
  title           String
  description     String
  imageUrl        String
  difficultyLevel Int

  segments    StorySegment[]
  completedBy CompletedStory[] // Relation to track completions

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model StorySegment {
  id          String  @id @default(uuid())
  type        String // "narration" or "choiceChallenge"
  textContent String  @db.Text // The raw text content
  audioUrl    String? // Stores the OBS Cloud URL (e.g. https://obs.../file.wav)
  orderIndex  Int     @default(0)

  imageUrl String?

  trailId    String
  storyTrail StoryTrail @relation(fields: [trailId], references: [id], onDelete: Cascade)

  challenge SingleChoiceChallenge? // A segment can have one challenge

  @@index([trailId])
}

model SingleChoiceChallenge {
  id                String  @id @default(uuid())
  prompt            String
  correctAnswerId   String // The ID of the correct choice
  correctFeedback   String?
  incorrectFeedback String?

  segmentId String       @unique // Each segment has only one challenge
  segment   StorySegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  choices Choice[]
}

model Choice {
  id       String  @id @default(uuid())
  text     String
  imageUrl String?

  challengeId String
  challenge   SingleChoiceChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@index([challengeId])
}

// Join table to track user progress (many-to-many relationship)
model CompletedStory {
  userId      String
  storyId     String
  completedAt DateTime @default(now())

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  story StoryTrail @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@id([userId, storyId]) // Composite primary key
}

model LearningShort {
  id        String @id @default(uuid())
  youtubeId String @unique @map("youtube_id") // The "dQw4w9WgXcQ" part

  // Metadata
  title        String
  description  String? @db.Text
  thumbnailUrl String? @map("thumbnail_url")
  channelName  String? @map("channel_name")
  duration     Int     @default(0) // In seconds

  // "Real English" Smart Tags
  difficultyLevel String @default("intermediate") @map("difficulty_level") // beginner, intermediate, advanced
  category        String @default("general") // funny, real_life, motivation, culture

  // Search Optimization (We will handle vector logic via Raw SQL in repo, but need a field)
  // Note: Prisma doesn't natively support TSVECTOR types perfectly yet, 
  // so we rely on raw queries for search, but we store text here.

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  watchedBy UserShortHistory[]

  @@map("learning_shorts")
}

// Track what users have watched so we don't show duplicates
model UserShortHistory {
  id      String @id @default(uuid())
  userId  String @map("user_id")
  shortId String @map("short_id")

  watchedAt DateTime @default(now()) @map("watched_at")
  isSaved   Boolean  @default(false) @map("is_saved") // If user "liked/saved" it

  short LearningShort @relation(fields: [shortId], references: [id])
  // user   User          @relation(...) // Assuming you have a User model

  @@unique([userId, shortId]) // User can only have one history entry per video
  @@map("user_short_history")
}
